diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
index eb6f45a..ac4c22f 100644
--- a/.idea/inspectionProfiles/Project_Default.xml
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -11,7 +11,6 @@
     <inspection_tool class="LongLine" enabled="true" level="WARNING" enabled_by_default="true" />
     <inspection_tool class="MarkdownIncorrectlyNumberedListItem" enabled="false" level="WARNING" enabled_by_default="false" />
     <inspection_tool class="ProblematicWhitespace" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="RsExperimentalAmbiguousMethodCall" enabled="true" level="ERROR" enabled_by_default="true" />
     <inspection_tool class="RsExperimentalChecks" enabled="true" level="ERROR" enabled_by_default="true" />
     <inspection_tool class="RsExperimentalTypeCheck" enabled="true" level="ERROR" enabled_by_default="true" />
     <inspection_tool class="RsExperimentalUnresolvedMethod" enabled="true" level="ERROR" enabled_by_default="true" />
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3048a6c..716540b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -9,6 +9,14 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+### Added
+
+* `Error::ReallocSmallerAlign` for when attempting to reallocate with a smaller new alignment.
+
+### Fixed
+
+* Reallocation with a smaller alignment is now an error, preventing some potential UB
+
 ---
 
 ## [0.11.3] - 2026-02-15
diff --git a/Cargo.toml b/Cargo.toml
index 338f4dd..60eaefe 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -83,23 +83,23 @@ cc = { version = "=1.0.83", optional = true }
 
 
 
-# [dev-dependencies]
-# criterion = "0.8.1"
-
-# [[bench]]
-# name = "lyt"
-# path = "benches/layout.rs"
-# harness = false
-
-# [[bench]]
-# name = "alc"
-# path = "benches/alloc.rs"
-# harness = false
-
-# [[bench]]
-# name = "hlp"
-# path = "benches/helpers.rs"
-# harness = false
+#[dev-dependencies]
+#criterion = "0.8.1"
+#
+#[[bench]]
+#name = "lyt"
+#path = "benches/layout.rs"
+#harness = false
+#
+#[[bench]]
+#name = "alc"
+#path = "benches/alloc.rs"
+#harness = false
+#
+#[[bench]]
+#name = "hlp"
+#path = "benches/helpers.rs"
+#harness = false
 
 
 
diff --git a/README.md b/README.md
index eec339f..12dc0ee 100644
--- a/README.md
+++ b/README.md
@@ -7,6 +7,7 @@ A small, `no_std`/`no_alloc`-friendly allocation interface for raw buffers, with
 split allocator traits, and structured errors.
 
 Version: 0.11.4
+
 MSRV: 1.46.0 (some features require newer compilers or nightly; see [Feature flags](#feature-flags))
 
 ## Highlights
@@ -66,8 +67,7 @@ fn main() -> Result<(), memapi2::error::Error> {
 - `os_err_reporting`: best-effort OS error reporting via `errno` (requires `std`)
 - `alloc_temp_trait`: scoped/temporary allocation trait (`AllocTemp`)
 - `c_alloc`: C `posix_memalign`-style allocator (`c_alloc::CAlloc`)
-- `stack_alloc`: `alloca`-based allocator (`stack_alloc::StackAlloc`, experimental, requires a C
-  toolchain)
+- `stack_alloc`: `alloca`-based allocator (`stack_alloc::StackAlloc`, requires a C toolchain)
 - `c_str`: enable `CStr`-specific data traits in `no_std` (MSRV: 1.64)
 - `metadata`: nightly `core::ptr::Pointee` metadata support
 - `sized_hierarchy`: nightly `core::marker::MetaSized` support
diff --git a/benches/alloc.rs b/benches/alloc.rs
index 0a98f21..9855dee 100644
--- a/benches/alloc.rs
+++ b/benches/alloc.rs
@@ -3,7 +3,6 @@
 extern crate criterion;
 extern crate memapi2;
 
-use std::sync::Mutex;
 use {
     core::hint::black_box,
     criterion::Criterion,
@@ -25,90 +24,84 @@ where
     group.bench_function("alloc", |b| {
         b.iter(|| {
             let l = black_box(small);
-            let ptr = alloc.alloc(l).unwrap();
-            unsafe { alloc.dealloc(ptr, l) };
+            let ptr = alloc.alloc(black_box(l)).unwrap();
+            unsafe { alloc.dealloc(black_box(ptr), black_box(l)) };
         });
     });
 
     group.bench_function("zalloc", |b| {
         b.iter(|| {
-            
             let l = black_box(small);
-            let ptr = alloc.zalloc(l).unwrap();
-            unsafe { alloc.dealloc(ptr, l) };
+            let ptr = alloc.zalloc(black_box(l)).unwrap();
+            unsafe { alloc.dealloc(black_box(ptr), black_box(l)) };
         });
     });
 
     group.bench_function("dealloc", |b| {
         b.iter(|| {
-            
             let l = black_box(small);
-            let ptr = alloc.alloc(l).unwrap();
-            unsafe { alloc.dealloc(ptr, l) };
+            let ptr = alloc.alloc(black_box(l)).unwrap();
+            unsafe { alloc.dealloc(black_box(ptr), black_box(l)) };
         });
     });
 
     group.bench_function("try_dealloc", |b| {
         b.iter(|| {
-            
             let l = black_box(small);
-            let ptr = alloc.alloc(l).unwrap();
-            unsafe { alloc.try_dealloc(ptr, l).unwrap() };
+            let ptr = alloc.alloc(black_box(l)).unwrap();
+            unsafe { alloc.try_dealloc(black_box(ptr), black_box(l)).unwrap() };
         });
     });
 
     group.bench_function("grow", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(small);
             let new_l = black_box(large);
-            let ptr = alloc.alloc(old_l).unwrap();
-            let new_ptr = alloc.grow(ptr, old_l, new_l).unwrap();
-            alloc.dealloc(new_ptr, new_l);
+            let ptr = alloc.alloc(black_box(old_l)).unwrap();
+            let new_ptr = alloc.grow(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc(black_box(new_ptr), black_box(new_l));
         });
     });
 
     group.bench_function("zgrow", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(small);
             let new_l = black_box(large);
-            let ptr = alloc.alloc(old_l).unwrap();
-            let new_ptr = alloc.zgrow(ptr, old_l, new_l).unwrap();
-            alloc.dealloc(new_ptr, new_l);
+            let ptr = alloc.alloc(black_box(old_l)).unwrap();
+            let new_ptr = alloc.zgrow(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc(black_box(new_ptr), black_box(new_l));
         });
     });
 
     group.bench_function("shrink", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(large);
             let new_l = black_box(small);
-            let ptr = alloc.alloc(old_l).unwrap();
-            let new_ptr = alloc.shrink(ptr, old_l, new_l).unwrap();
-            alloc.dealloc(new_ptr, new_l);
+            let ptr = alloc.alloc(black_box(old_l)).unwrap();
+            let new_ptr = alloc.shrink(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc(black_box(new_ptr), black_box(new_l));
         });
     });
 
     group.bench_function("realloc", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(small);
             let new_l = black_box(large);
-            let ptr = alloc.alloc(old_l).unwrap();
-            let new_ptr = alloc.realloc(ptr, old_l, new_l).unwrap();
-            alloc.dealloc(new_ptr, new_l);
+            let ptr = alloc.alloc(black_box(old_l)).unwrap();
+            let new_ptr =
+                alloc.realloc(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc(black_box(new_ptr), black_box(new_l));
         });
     });
 
     group.bench_function("rezalloc", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(small);
             let new_l = black_box(large);
-            let ptr = alloc.alloc(old_l).unwrap();
-            let new_ptr = alloc.rezalloc(ptr, old_l, new_l).unwrap();
-            alloc.dealloc(new_ptr, new_l);
+            let ptr = alloc.alloc(black_box(old_l)).unwrap();
+            let new_ptr =
+                alloc.rezalloc(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc(black_box(new_ptr), black_box(new_l));
         });
     });
 
@@ -127,92 +120,88 @@ where
 
     group.bench_function("alloc_mut", |b| {
         b.iter(|| {
-            
             let l = black_box(small);
-            let ptr = alloc.alloc_mut(l).unwrap();
-            unsafe { alloc.dealloc_mut(ptr, l) };
+            let ptr = alloc.alloc_mut(black_box(l)).unwrap();
+            unsafe { alloc.dealloc_mut(black_box(ptr), black_box(l)) };
         });
     });
 
     group.bench_function("zalloc_mut", |b| {
         b.iter(|| {
-            
             let l = black_box(small);
-            let ptr = alloc.zalloc_mut(l).unwrap();
-            unsafe { alloc.dealloc_mut(ptr, l) };
+            let ptr = alloc.zalloc_mut(black_box(l)).unwrap();
+            unsafe { alloc.dealloc_mut(black_box(ptr), black_box(l)) };
         });
     });
 
     group.bench_function("dealloc_mut", |b| {
         b.iter(|| {
-            
             let l = black_box(small);
-            let ptr = alloc.alloc_mut(l).unwrap();
-            unsafe { alloc.dealloc_mut(ptr, l) };
+            let ptr = alloc.alloc_mut(black_box(l)).unwrap();
+            unsafe { alloc.dealloc_mut(black_box(ptr), black_box(l)) };
         });
     });
 
     group.bench_function("try_dealloc_mut", |b| {
         b.iter(|| {
-            
             let l = black_box(small);
-            let ptr = alloc.alloc_mut(l).unwrap();
-            unsafe { alloc.try_dealloc_mut(ptr, l).unwrap() };
+            let ptr = alloc.alloc_mut(black_box(l)).unwrap();
+            unsafe { alloc.try_dealloc_mut(black_box(ptr), black_box(l)).unwrap() };
         });
     });
 
     group.bench_function("grow_mut", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(small);
             let new_l = black_box(large);
-            let ptr = alloc.alloc_mut(old_l).unwrap();
-            let new_ptr = alloc.grow_mut(ptr, old_l, new_l).unwrap();
-            alloc.dealloc_mut(new_ptr, new_l);
+            let ptr = alloc.alloc_mut(black_box(old_l)).unwrap();
+            let new_ptr =
+                alloc.grow_mut(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc_mut(black_box(new_ptr), black_box(new_l));
         });
     });
 
     group.bench_function("zgrow_mut", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(small);
             let new_l = black_box(large);
-            let ptr = alloc.alloc_mut(old_l).unwrap();
-            let new_ptr = alloc.zgrow_mut(ptr, old_l, new_l).unwrap();
-            alloc.dealloc_mut(new_ptr, new_l);
+            let ptr = alloc.alloc_mut(black_box(old_l)).unwrap();
+            let new_ptr =
+                alloc.zgrow_mut(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc_mut(black_box(new_ptr), black_box(new_l));
         });
     });
 
     group.bench_function("shrink_mut", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(large);
             let new_l = black_box(small);
-            let ptr = alloc.alloc_mut(old_l).unwrap();
-            let new_ptr = alloc.shrink_mut(ptr, old_l, new_l).unwrap();
-            alloc.dealloc_mut(new_ptr, new_l);
+            let ptr = alloc.alloc_mut(black_box(old_l)).unwrap();
+            let new_ptr =
+                alloc.shrink_mut(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc_mut(black_box(new_ptr), black_box(new_l));
         });
     });
 
     group.bench_function("realloc_mut", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(small);
             let new_l = black_box(large);
-            let ptr = alloc.alloc_mut(old_l).unwrap();
-            let new_ptr = alloc.realloc_mut(ptr, old_l, new_l).unwrap();
-            alloc.dealloc_mut(new_ptr, new_l);
+            let ptr = alloc.alloc_mut(black_box(old_l)).unwrap();
+            let new_ptr =
+                alloc.realloc_mut(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc_mut(black_box(new_ptr), black_box(new_l));
         });
     });
 
     group.bench_function("rezalloc_mut", |b| {
         b.iter(|| unsafe {
-            
             let old_l = black_box(small);
             let new_l = black_box(large);
-            let ptr = alloc.alloc_mut(old_l).unwrap();
-            let new_ptr = alloc.rezalloc_mut(ptr, old_l, new_l).unwrap();
-            alloc.dealloc_mut(new_ptr, new_l);
+            let ptr = alloc.alloc_mut(black_box(old_l)).unwrap();
+            let new_ptr =
+                alloc.rezalloc_mut(black_box(ptr), black_box(old_l), black_box(new_l)).unwrap();
+            alloc.dealloc_mut(black_box(new_ptr), black_box(new_l));
         });
     });
 
@@ -230,14 +219,14 @@ where
     group.bench_function("alloc_temp", |b| {
         b.iter(|| unsafe {
             let l = black_box(small);
-            let _ = alloc.alloc_temp(l, |ptr| black_box(ptr)).unwrap();
+            let _ = alloc.alloc_temp(black_box(l), |ptr| black_box(ptr)).unwrap();
         });
     });
 
     group.bench_function("zalloc_temp", |b| {
         b.iter(|| unsafe {
             let l = black_box(small);
-            let _ = alloc.zalloc_temp(l, |ptr| black_box(ptr)).unwrap();
+            let _ = alloc.zalloc_temp(black_box(l), |ptr| black_box(ptr)).unwrap();
         });
     });
 
@@ -258,8 +247,9 @@ fn main() {
     bench_allocs_mut(&mut c, "default_alloc_mut", DefaultAlloc);
     #[cfg(feature = "c_alloc")]
     bench_allocs_mut(&mut c, "c_alloc_mut", memapi2::allocs::c_alloc::CAlloc);
-    
-    bench_allocs(&mut c, "default_alloc_mut_wrapped", Mutex::new(DefaultAlloc));
+
+    #[cfg(feature = "std")]
+    bench_allocs(&mut c, "default_alloc_mut_wrapped", std::sync::Mutex::new(DefaultAlloc));
 
     #[cfg(feature = "alloc_temp_trait")]
     {
diff --git a/benches/helpers.rs b/benches/helpers.rs
index d7f691d..28357e6 100644
--- a/benches/helpers.rs
+++ b/benches/helpers.rs
@@ -4,9 +4,16 @@ extern crate criterion;
 extern crate memapi2;
 
 use {
-    core::hint::black_box,
+    core::{
+        hint::black_box,
+        ptr::{dangling_mut, null_mut}
+    },
     criterion::Criterion,
-    memapi2::{error::ArithOp, helpers::checked_op}
+    memapi2::{
+        error::ArithOp,
+        helpers::{checked_op, null_q, null_q_dyn, null_q_dyn_zsl_check},
+        layout::Layout
+    }
 };
 
 fn checked_ops(c: &mut Criterion) {
@@ -139,7 +146,8 @@ fn checked_ops(c: &mut Criterion) {
 
     group.bench_function("invalid_toolarge", |b| {
         b.iter(|| {
-            let _ = black_box(checked_op(black_box(2), ArithOp::Pow, black_box(u32::MAX as usize + 1)));
+            let _ =
+                black_box(checked_op(black_box(2), ArithOp::Pow, black_box(u32::MAX as usize + 1)));
         });
     });
 
@@ -158,6 +166,75 @@ fn checked_ops(c: &mut Criterion) {
     group.finish();
 }
 
+fn null_q_variants(c: &mut Criterion) {
+    let mut group = c.benchmark_group("null_q");
+
+    let invalid_ptr: *mut u8 = null_mut();
+    let valid_ptr: *mut u8 = dangling_mut();
+
+    let layout = Layout::new::<usize>();
+    let zsl_layout = Layout::from_size_align(0, 1).unwrap();
+
+    group.bench_function("null_q_valid", |b| {
+        b.iter(|| black_box(null_q(black_box(valid_ptr), black_box(layout))))
+    });
+    group.bench_function("null_q_invalid", |b| {
+        b.iter(|| black_box(null_q(black_box(invalid_ptr), black_box(layout))))
+    });
+
+    group.bench_function("null_q_dyn_valid", |b| {
+        b.iter(|| black_box(null_q_dyn(black_box(valid_ptr), black_box(layout))))
+    });
+    group.bench_function("null_q_dyn_invalid", |b| {
+        b.iter(|| black_box(null_q_dyn(black_box(invalid_ptr), black_box(layout))))
+    });
+
+    group.bench_function("null_q_dyn_zsl_check_valid", |b| {
+        b.iter(|| {
+            let _ = black_box(null_q_dyn_zsl_check(
+                black_box(layout),
+                black_box(|l| {
+                    black_box(l);
+                    black_box(valid_ptr)
+                })
+            ));
+        });
+    });
+    group.bench_function("null_q_dyn_zsl_check_invalid_ptr", |b| {
+        b.iter(|| {
+            let _ = black_box(null_q_dyn_zsl_check(
+                black_box(layout),
+                black_box(|l| {
+                    black_box(l);
+                    black_box(invalid_ptr)
+                })
+            ));
+        });
+    });
+    group.bench_function("null_q_dyn_zsl_check_invalid_layout", |b| {
+        b.iter(|| {
+            let _ = black_box(null_q_dyn_zsl_check(
+                black_box(zsl_layout),
+                black_box(|l| {
+                    black_box(l);
+                    black_box(valid_ptr)
+                })
+            ));
+        });
+    });
+    group.bench_function("null_q_dyn_zsl_check_invalid", |b| {
+        b.iter(|| {
+            let _ = black_box(null_q_dyn_zsl_check(
+                black_box(zsl_layout),
+                black_box(|l| {
+                    black_box(l);
+                    black_box(invalid_ptr)
+                })
+            ));
+        });
+    });
+}
+
 fn main() {
     let mut c = Criterion::default()
         .sample_size(512)
@@ -166,6 +243,7 @@ fn main() {
         .configure_from_args();
 
     checked_ops(&mut c);
+    null_q_variants(&mut c);
 
     c.final_summary();
 }
diff --git a/src/allocs/c_alloc.rs b/src/allocs/c_alloc.rs
index 940fec5..eff0033 100644
--- a/src/allocs/c_alloc.rs
+++ b/src/allocs/c_alloc.rs
@@ -1,7 +1,8 @@
 use {
     crate::{
         error::{Cause, Error},
-        ffi::c_alloc::{c_alloc, c_dealloc, c_zalloc, grow_aligned, shrink_aligned},
+        ffi::c_alloc::{c_alloc, c_dealloc, c_zalloc},
+        helpers::null_q_dyn,
         layout::Layout,
         traits::{
             AllocError,
@@ -9,7 +10,7 @@ use {
         }
     },
     ::core::{
-        cmp::{Ord, Ordering},
+        cmp::Ord,
         ffi::c_void,
         ops::Fn,
         ptr::NonNull,
@@ -18,14 +19,6 @@ use {
     ::cty::c_int
 };
 
-macro_rules! sz_check {
-    ($err:ident, $old:ident $cmp:tt $new:ident) => {
-        if $old.size() $cmp $new.size() {
-            return Err(Error::$err($old.size(), $new.size()));
-        }
-    };
-}
-
 fn null_q_dyn_zsl_check_or_errcode<F: Fn(Layout) -> (*mut c_void, c_int)>(
     layout: Layout,
     f: F
@@ -34,98 +27,27 @@ fn null_q_dyn_zsl_check_or_errcode<F: Fn(Layout) -> (*mut c_void, c_int)>(
         Err(Error::ZeroSizedLayout)
     } else {
         let (ptr, status) = f(layout);
-        if status == -1 {
+        match status {
             // SAFETY: errcode of -1 means it's already been checked and is guaranteed success
-            Ok(unsafe { NonNull::new_unchecked(ptr.cast()) })
-        } else if status == 0 {
-            null_q_dyn(ptr, layout)
-        } else {
-            #[cfg(feature = "os_err_reporting")]
-            {
-                Err(Error::AllocFailed(layout, Cause::OSErr(status as c_int)))
-            }
-            #[cfg(not(feature = "os_err_reporting"))]
-            {
-                Err(Error::AllocFailed(layout, Cause::Unknown))
-            }
-        }
-    }
-}
-
-#[cfg_attr(miri, track_caller)]
-fn pad_then_alloc(layout: Layout, zeroed: bool) -> Result<NonNull<u8>, Error> {
-    let padded = tri!(do layout.to_posix_memalign_compatible());
-    let fun = if zeroed { c_zalloc } else { c_alloc };
-    // SAFETY: padded layout meets the function's requirements
-    null_q_dyn_zsl_check_or_errcode(layout, |_| unsafe { fun(padded.align(), padded.size()) })
-}
-
-#[cfg_attr(miri, track_caller)]
-unsafe fn pad_then_grow(
-    ptr: NonNull<u8>,
-    old_layout: Layout,
-    new_layout: Layout,
-    zeroed: bool
-) -> Result<NonNull<u8>, Error> {
-    sz_check!(GrowSmallerNewLayout, old_layout > new_layout);
-
-    let old_padded = tri!(do old_layout.to_posix_memalign_compatible());
-    let new_padded = tri!(do new_layout.to_posix_memalign_compatible());
-
-    null_q_dyn_zsl_check_or_errcode(new_layout, |_| {
-        grow_aligned(
-            ptr.as_ptr().cast(),
-            old_padded.align(),
-            old_padded.size(),
-            new_padded.align(),
-            new_padded.size(),
-            zeroed
-        )
-    })
-}
-
-#[cfg_attr(miri, track_caller)]
-unsafe fn pad_then_realloc(
-    ptr: NonNull<u8>,
-    old_layout: Layout,
-    new_layout: Layout,
-    zeroed: bool
-) -> Result<NonNull<u8>, Error> {
-    let old_padded = tri!(do old_layout.to_posix_memalign_compatible());
-    let new_padded = tri!(do new_layout.to_posix_memalign_compatible());
-
-    null_q_dyn_zsl_check_or_errcode(new_layout, |_| {
-        let old_ptr = ptr.as_ptr().cast();
-        let old_size = old_padded.size();
-        let old_align = old_padded.align();
-
-        let size = new_padded.size();
-        let align = new_padded.align();
-
-        match old_size.cmp(&new_padded.size()) {
-            // SAFETY: caller guarantees that `old_ptr` and `old_size` are valid, we just
-            // checked that `size >= old_size`
-            Ordering::Less => unsafe {
-                grow_aligned(old_ptr, old_align, old_size, align, size, zeroed)
-            },
-            Ordering::Equal => {
-                if align > old_align {
-                    // SAFETY: above
-                    unsafe { grow_aligned(old_ptr, old_align, old_size, align, size, zeroed) }
-                } else {
-                    (old_ptr, -1)
+            -1 => Ok(unsafe { NonNull::new_unchecked(ptr.cast()) }),
+            0 => null_q_dyn(ptr, layout),
+            code => {
+                #[cfg(feature = "os_err_reporting")]
+                {
+                    Err(Error::AllocFailed(layout, Cause::OSErr(code as c_int)))
+                }
+                #[cfg(not(feature = "os_err_reporting"))]
+                {
+                    Err(Error::AllocFailed(layout, Cause::Unknown))
                 }
-            }
-            // SAFETY: caller guarantees that `old_ptr` and `size` are valid, we just checked
-            // that `size <= old_size`
-            Ordering::Greater => unsafe {
-                shrink_aligned(old_ptr, old_align, old_size, align, size)
             }
         }
-    })
+    }
 }
 
-/// An allocator which uses C's [`c_alloc`] set of allocation methods.
+#[cfg_attr(feature = "dev", allow(rustdoc::broken_intra_doc_links))]
+/// An allocator which uses C's allocation functions; [`posix_memalign`](ffi::posix_memalign) on
+/// unix and [`_aligned_malloc`](ffi::_aligned_malloc) on Windows.
 ///
 /// Note that layouts passed to this allocator's allocation methods will have their size and
 /// alignment rounded up to meet C's [`c_alloc`] requirements. See
@@ -141,13 +63,21 @@ impl Alloc for CAlloc {
     #[cfg_attr(miri, track_caller)]
     #[inline]
     fn alloc(&self, layout: Layout) -> Result<NonNull<u8>, Error> {
-        pad_then_alloc(layout, false)
+        null_q_dyn_zsl_check_or_errcode(
+            layout,
+            // SAFETY: we check the layout is non-zero-sized before use.
+            |l| unsafe { c_alloc(l.align(), l.size()) }
+        )
     }
 
     #[cfg_attr(miri, track_caller)]
     #[inline]
     fn zalloc(&self, layout: Layout) -> Result<NonNull<u8>, Error> {
-        pad_then_alloc(layout, true)
+        null_q_dyn_zsl_check_or_errcode(
+            layout,
+            // SAFETY: we check the layout is non-zero-sized before use.
+            |l| unsafe { c_zalloc(l.align(), l.size()) }
+        )
     }
 }
 impl Dealloc for CAlloc {
@@ -165,70 +95,8 @@ impl Dealloc for CAlloc {
         }
     }
 }
-impl Grow for CAlloc {
-    #[cfg_attr(miri, track_caller)]
-    unsafe fn grow(
-        &self,
-        ptr: NonNull<u8>,
-        old_layout: Layout,
-        new_layout: Layout
-    ) -> Result<NonNull<u8>, Error> {
-        pad_then_grow(ptr, old_layout, new_layout, false)
-    }
-    #[cfg_attr(miri, track_caller)]
-    unsafe fn zgrow(
-        &self,
-        ptr: NonNull<u8>,
-        old_layout: Layout,
-        new_layout: Layout
-    ) -> Result<NonNull<u8>, Error> {
-        pad_then_grow(ptr, old_layout, new_layout, true)
-    }
-}
-impl Shrink for CAlloc {
-    #[cfg_attr(miri, track_caller)]
-    unsafe fn shrink(
-        &self,
-        ptr: NonNull<u8>,
-        old_layout: Layout,
-        new_layout: Layout
-    ) -> Result<NonNull<u8>, Error> {
-        sz_check!(ShrinkLargerNewLayout, old_layout < new_layout);
-
-        let old_padded = tri!(do old_layout.to_posix_memalign_compatible());
-        let new_padded = tri!(do new_layout.to_posix_memalign_compatible());
-
-        null_q_dyn_zsl_check_or_errcode(new_layout, |_| {
-            shrink_aligned(
-                ptr.as_ptr().cast(),
-                old_padded.align(),
-                old_padded.size(),
-                new_padded.align(),
-                new_padded.size()
-            )
-        })
-    }
-}
-impl Realloc for CAlloc {
-    #[cfg_attr(miri, track_caller)]
-    unsafe fn realloc(
-        &self,
-        ptr: NonNull<u8>,
-        old_layout: Layout,
-        new_layout: Layout
-    ) -> Result<NonNull<u8>, Error> {
-        pad_then_realloc(ptr, old_layout, new_layout, false)
-    }
-    #[cfg_attr(miri, track_caller)]
-    unsafe fn rezalloc(
-        &self,
-        ptr: NonNull<u8>,
-        old_layout: Layout,
-        new_layout: Layout
-    ) -> Result<NonNull<u8>, Error> {
-        pad_then_realloc(ptr, old_layout, new_layout, true)
-    }
-}
+impl Grow for CAlloc {}
+impl Shrink for CAlloc {}
+impl Realloc for CAlloc {}
 
 pub use crate::ffi::c_alloc as ffi;
-use crate::helpers::null_q_dyn;
diff --git a/src/allocs/stack_alloc.rs b/src/allocs/stack_alloc.rs
index b7b67b0..458ae66 100644
--- a/src/allocs/stack_alloc.rs
+++ b/src/allocs/stack_alloc.rs
@@ -15,13 +15,13 @@ use {
 /// An allocator that uses C's `alloca` for stack allocation.
 ///
 /// This satisfies the requested alignment by allocating extra space and aligning within it. Ensure
-/// <code>[layout.size()](Layout::size) + ([layout.align()](Layout::align) - 1)</code> does not
+/// <code>layout.[size](Layout::size)() + (layout.[align](Layout::align)() - 1)</code> does not
 /// exceed the stack limit to avoid overflow.
 ///
 /// # Safety
 ///
 /// The caller must ensure:
-/// - attempting to allocate <code>[layout.size()](Layout::size) + ([layout.align()](Layout::align)
+/// - attempting to allocate <code>layout.[size](Layout::size)() + (layout.[align](Layout::align)()
 ///   \- 1)</code> bytes on the stack will not cause a stack overflow.
 /// - if compiling with a Rust version below `1.71` and the `catch_unwind` feature is disabled, the
 ///   `with_mem` function passed to allocation methods will never unwind.
@@ -42,19 +42,6 @@ impl AllocTemp for StackAlloc {
             ptr::write(uninit, with_mem(ptr));
         })
     }
-
-    #[cfg_attr(miri, track_caller)]
-    #[inline]
-    unsafe fn zalloc_temp<R, F: FnOnce(NonNull<u8>) -> R>(
-        &self,
-        layout: Layout,
-        with_mem: F
-    ) -> Result<R, Error> {
-        with_alloca(layout, |ptr, uninit: *mut R| {
-            ptr::write_bytes(ptr.as_ptr(), 0, layout.size());
-            ptr::write(uninit, with_mem(ptr));
-        })
-    }
 }
 
 pub use crate::ffi::stack_alloc as ffi;
diff --git a/src/error.rs b/src/error.rs
index 7c711a6..2c7d148 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -37,12 +37,14 @@ pub enum Error {
     /// In most reasonable cases, [`layout.dangling()`](Layout::dangling) can and should be used
     /// instead.
     ZeroSizedLayout,
-    /// An attempt was made to deallocate a dangling pointer.
+    /// Attempted to deallocate a dangling pointer.
     DanglingDeallocation,
     /// Attempted to grow to a smaller size.
     GrowSmallerNewLayout(usize, usize),
     /// Attempted to shrink to a larger size.
     ShrinkLargerNewLayout(usize, usize),
+    /// Attempted to reallocate a block with a smaller alignment.
+    ReallocSmallerAlign(usize, usize),
     /// An arithmetic error.
     ArithmeticError(ArithErr),
     /// An unwinding panic occurred in a function which does not support unwinding; likely FFI.
@@ -63,6 +65,7 @@ impl Display for Error {
             GrowSmallerNewLayout,
             InvalidLayout,
             Other,
+            ReallocSmallerAlign,
             ShrinkLargerNewLayout,
             Unsupported,
             ZeroSizedLayout
@@ -91,6 +94,13 @@ impl Display for Error {
             ShrinkLargerNewLayout(old, new) => {
                 write!(f, "attempted to shrink from a size of {} to a larger size of {}", old, new)
             }
+            ReallocSmallerAlign(old, new) => {
+                write!(
+                    f,
+                    "attempted to reallocate from an align of {} to a smaller align of {}",
+                    old, new
+                )
+            }
             ArithmeticError(overflow) => write!(f, "{}", overflow),
             CaughtUnwind => {
                 write!(f, "unwind caught in unsupported function")
diff --git a/src/ffi/c_alloc.rs b/src/ffi/c_alloc.rs
index dcd96fe..ab23c11 100644
--- a/src/ffi/c_alloc.rs
+++ b/src/ffi/c_alloc.rs
@@ -122,35 +122,6 @@ pub const MIN_ALIGN: usize = 1;
 
 const NULL: *mut c_void = null_mut();
 
-/// Copies `size` bytes from `old_ptr` to `ptr` when `ptr` is non-null, then deallocates `old_ptr`.
-///
-/// If `ptr` is `NULL`, this is a no-op and `old_ptr` is not freed.
-///
-/// # Safety
-///
-/// - `old_ptr` must point to a C allocation of at least `size` bytes.
-/// - `ptr` must point to an allocation of at least `size` bytes.
-pub unsafe fn try_move(
-    ptr: *mut c_void,
-    old_ptr: *mut c_void,
-    copy_count: usize,
-    old_align: usize,
-    old_size: usize
-) {
-    if ptr != NULL {
-        // SAFETY: `ptr` validated nonnull, caller guarantees `old_ptr` is valid. caller guarantees
-        // `size` is <= size of allocation at `ptr` and <= size of allocation at `old_ptr`,
-        // so copying that many bytes is safe.
-        unsafe {
-            ptr::copy_nonoverlapping(old_ptr, ptr, copy_count);
-        }
-        // SAFETY: caller guarantees that `old_ptr` is valid
-        unsafe {
-            c_dealloc(old_ptr, old_align, old_size);
-        }
-    }
-}
-
 /// Allocates `size` bytes with at least `align` alignment.
 ///
 /// The closest Rust equivalent is [`alloc`](::stdalloc::alloc::alloc).
@@ -173,7 +144,7 @@ pub unsafe fn try_move(
 #[must_use = "this function allocates memory on success, and dropping the returned pointer will \
               leak memory"]
 pub unsafe fn c_alloc(align: usize, size: usize) -> (*mut c_void, c_int) {
-    if align > MIN_ALIGN && size >= align {
+    if size_align_check(size, align) {
         // SAFETY: requirements are passed on to caller
         unsafe { c_alloc_spec(align, size) }
     } else {
@@ -210,6 +181,17 @@ unsafe fn c_alloc_spec(layout: &Layout) -> *mut c_void {
     (unsafe { memalign(layout.align(), layout.size()) }, 0)
 }
 
+#[cfg(windows)]
+#[inline(always)]
+const fn size_align_check(_: usize, align: usize) -> bool {
+    align > MIN_ALIGN
+}
+#[cfg(not(windows))]
+#[inline(always)]
+const fn size_align_check(size: usize, align: usize) -> bool {
+    align > MIN_ALIGN && size >= align
+}
+
 /// Allocates `size` bytes with at least `align` alignment and zeroes the allocation.
 ///
 /// # Returns
@@ -227,7 +209,7 @@ unsafe fn c_alloc_spec(layout: &Layout) -> *mut c_void {
 #[must_use = "this function allocates memory on success, and dropping the returned pointer will \
               leak memory"]
 pub unsafe fn c_zalloc(align: usize, size: usize) -> (*mut c_void, c_int) {
-    if align > MIN_ALIGN && size >= align {
+    if size_align_check(size, align) {
         // SAFETY: requirements are passed on to caller
         let (ptr, status) = unsafe { c_alloc_spec(align, size) };
         // zero memory if allocation was successful
@@ -244,8 +226,8 @@ pub unsafe fn c_zalloc(align: usize, size: usize) -> (*mut c_void, c_int) {
     }
 }
 
-/// Frees memory previously returned by [`c_alloc`], [`c_zalloc`], [`c_realloc`], [`malloc`],
-/// [`calloc`], [`realloc`], [`grow_aligned`], or [`shrink_aligned`].
+/// Frees memory previously returned by [`c_alloc`], [`c_zalloc`], [`malloc`], [`calloc`], or
+/// [`realloc`].
 ///
 /// The closest Rust equivalent is [`dealloc`](::stdalloc::alloc::dealloc).
 ///
@@ -259,7 +241,7 @@ pub unsafe fn c_dealloc(ptr: *mut c_void, _size: usize, _align: usize) {
     #[cfg(windows)]
     {
         #[allow(clippy::used_underscore_binding)]
-        if _align > MIN_ALIGN && _size >= _align {
+        if size_align_check(_size, _align) {
             // SAFETY: requirements are passed onto the caller; as align > MIN_ALIGN,
             // _aligned_{malloc,realloc} was used so _aligned_free works.
             unsafe {
@@ -282,94 +264,6 @@ pub unsafe fn c_dealloc(ptr: *mut c_void, _size: usize, _align: usize) {
     }
 }
 
-/// Grows a block of memory previously returned by [`c_alloc`], [`c_zalloc`], [`c_realloc`],
-/// [`malloc`], [`calloc`], [`realloc`], [`grow_aligned`], or [`shrink_aligned`].
-///
-/// Allocates a new block of `size` bytes with at least `align` alignment, copies `old_size`
-/// bytes from `old_ptr` into the new block, frees the old block, and returns the new pointer. New
-/// bytes will be uninitialized if `zeroed` is `false`.
-///
-/// # Returns
-///
-/// - On success returns a nonnull pointer to the new allocation.
-/// - On allocation failure returns `NULL` and does **not** free the original allocation.
-///
-/// # Safety
-///
-/// The caller must ensure:
-/// - `old_ptr` was allocated by an allocation function listed above and is valid for reads of
-///   `old_size` bytes.
-/// - `old_align` equals the alignment of the allocation requested at `old_ptr`.
-/// - `old_size` equals the size of the allocation requested at `old_ptr`.
-/// - `align` is a power of two and non-zero.
-/// - `size` is greater than or equal to `old_size` and non-zero.
-#[cfg_attr(miri, track_caller)]
-pub unsafe fn grow_aligned(
-    old_ptr: *mut c_void,
-    old_align: usize,
-    old_size: usize,
-    align: usize,
-    size: usize,
-    zeroed: bool
-) -> (*mut c_void, c_int) {
-    // allocate new aligned memory
-    let (ptr, status) =
-        // SAFETY: requirements are passed onto the caller
-        if zeroed { unsafe { c_zalloc(align, size) } } else { unsafe { c_alloc(align, size) } };
-    // TODO: use realloc instead where possible
-
-    // if successful, move data to new pointer
-    // SAFETY: requirements are passed on to the caller
-    unsafe {
-        try_move(ptr, old_ptr, old_size, old_align, old_size);
-    }
-
-    (ptr, status)
-}
-
-
-/// Shrinks a block of memory previously returned by [`c_alloc`], [`c_zalloc`], [`c_realloc`],
-/// [`malloc`], [`calloc`], [`realloc`], [`grow_aligned`], or [`shrink_aligned`].
-///
-/// Allocates a new block of `size` bytes with at least `align` alignment, copies `size` bytes
-/// from `old_ptr` into the new block, frees the old block, and returns the new pointer.
-///
-/// # Returns
-///
-/// - On success returns a nonnull pointer to the new allocation.
-/// - On allocation failure returns `NULL` and does __not__ free the original allocation.
-///
-/// # Safety
-///
-/// The caller must ensure:
-/// - `old_ptr` was allocated by an allocation function listed above and is valid for reads of
-///   `size` bytes.
-/// - `old_align` equals the alignment of the allocation requested at `old_ptr`.
-/// - `old_size` equals the size of the allocation requested at `old_ptr`.
-/// - `align` is a power of two and non-zero.
-/// - `size` is less than or equal to `old_size` and non-zero.
-#[cfg_attr(miri, track_caller)]
-pub unsafe fn shrink_aligned(
-    old_ptr: *mut c_void,
-    old_align: usize,
-    old_size: usize,
-    align: usize,
-    size: usize // a zero here is useless, as it will just be overwritten anyway.
-) -> (*mut c_void, c_int) {
-    // allocate new aligned memory
-    // SAFETY: requirements are passed onto the caller
-    let (ptr, status) = unsafe { c_alloc(align, size) };
-    // TODO: use realloc
-
-    // if successful, move data to new pointer
-    // SAFETY: requirements are passed on to the caller
-    unsafe {
-        try_move(ptr, old_ptr, size, old_align, old_size);
-    }
-
-    (ptr, status)
-}
-
 // public in case the user wants them for some reason
 extern "C" {
     /// Allocates `size` bytes of uninitialized storage.
@@ -422,7 +316,7 @@ extern "C" {
     ///
     /// - Returns a pointer suitably aligned for any object type with fundamental alignment
     ///   (`max_align_t`, at least [`MIN_ALIGN`]).
-    /// - If `ptr` is non-null, it must have been returned by [`malloc`], [`calloc`].
+    /// - If `ptr` is non-null, it must have been returned by [`malloc`], [`calloc`],
     ///   [`posix_memalign`], or a previous [`realloc`] and must not have been freed.
     /// - If the call fails, it returns `NULL` and the original `ptr` remains valid.
     /// - If `size == 0`, the result is implementation-defined and may be `NULL` or a unique pointer
@@ -543,36 +437,10 @@ extern "C" {
     ///   [`_aligned_realloc`]/[`_aligned_recalloc`], or another compatible allocator, and not yet
     ///   freed.
     /// - On failure returns `NULL` and the original pointer remains valid.
-    pub fn _aligned_recalloc(ptr: *mut c_void, num: usize, size: usize, align: usize) -> *mut c_void;
-
-    /// Set `count` bytes starting at `ptr` to the byte value `val`. Returns `ptr`.
-    ///
-    /// C reference: <https://en.cppreference.com/w/c/string/byte/memset>.
-    ///
-    /// # Safety
-    ///
-    /// - `ptr` must be valid for writes of at least `count` bytes.
-    /// - `val` is converted to `unsigned char`/`u8` before being stored.
-    pub fn memset(ptr: *mut c_void, val: i32, count: usize) -> *mut c_void;
-
-    /// Copy `count` bytes from `src` to `dest`. The regions must not overlap. Returns `dest`.
-    ///
-    /// C reference: <https://en.cppreference.com/w/c/string/byte/memcpy>.
-    ///
-    /// # Safety
-    ///
-    /// - `src` must be valid for reads of at least `count` bytes.
-    /// - `dest` must be valid for writes of at least `count` bytes.
-    /// - The source and destination must not overlap.
-    pub fn memcpy(dest: *mut c_void, src: *const c_void, count: usize) -> *mut c_void;
-
-    /// Copy `count` bytes from `src` to `dest`. The regions may overlap. Returns `dest`.
-    ///
-    /// C reference: <https://en.cppreference.com/w/c/string/byte/memmove>.
-    ///
-    /// # Safety
-    ///
-    /// - `src` must be valid for reads of at least `count` bytes.
-    /// - `dest` must be valid for writes of at least `count` bytes.
-    pub fn memmove(dest: *mut c_void, src: *const c_void, count: usize) -> *mut c_void;
+    pub fn _aligned_recalloc(
+        ptr: *mut c_void,
+        num: usize,
+        size: usize,
+        align: usize
+    ) -> *mut c_void;
 }
diff --git a/src/ffi/stack_alloc.rs b/src/ffi/stack_alloc.rs
index 3291e0d..b50f475 100644
--- a/src/ffi/stack_alloc.rs
+++ b/src/ffi/stack_alloc.rs
@@ -21,7 +21,7 @@ use {
 ///
 /// The allocation is only valid for the duration of the call.
 ///
-/// If [`layout.size()`](Layout::size) is zero, `f` will receive a
+/// If <code>layout.[size](Layout::size)()</code> is zero, `f` will receive a
 /// [`dangling`](::core::ptr::dangling) pointer.
 ///
 /// # Errors
@@ -31,7 +31,7 @@ use {
 /// # Safety
 ///
 /// The caller must ensure:
-/// - `layout` is valid and <code>[layout.size()](Layout::size) + ([layout.align()](Layout::align) -
+/// - `layout` is valid and <code>layout.[size](Layout::size)() + (layout.[align](Layout::align)() -
 ///   1)</code> will not exceed the stack allocation limit.
 /// - If `layout.size() == 0`, `f` must treat the pointer as a [`dangling`](::core::ptr::dangling)
 ///   pointer.
diff --git a/src/helpers.rs b/src/helpers.rs
index 42f4ecd..794ba2a 100644
--- a/src/helpers.rs
+++ b/src/helpers.rs
@@ -299,8 +299,8 @@ pub fn varsized_ptr_from_parts<T: ?Sized + VarSized>(p: *const u8, meta: usize)
     unsafe { crate::helpers::union_transmute::<(*const u8, usize), *const T>((p, meta)) }
 }
 
-// Allocation/Result helpers
-
+// for some reason, making these non-generic to take a *mut u8 instead causes up to a +590% perf
+// loss soooo.. not doing that, i guess.
 /// Converts a possibly null pointer into a [`NonNull`] result.
 ///
 /// # Errors
@@ -368,7 +368,7 @@ pub fn null_q_dyn<T>(ptr: *mut T, layout: Layout) -> Result<NonNull<u8>, Error>
 ///   is typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
 ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
 ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-/// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) == 0</code>.
+/// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() == 0</code>.
 ///
 /// [last_os_error]: ::std::io::Error::last_os_error
 /// [raw_os_error]: ::std::io::Error::raw_os_error
diff --git a/src/layout.rs b/src/layout.rs
index 4ae90ab..f65b14b 100644
--- a/src/layout.rs
+++ b/src/layout.rs
@@ -364,8 +364,8 @@ impl Layout {
     /// # Errors
     ///
     /// <code>Err([Error::ArithmeticError])</code> if multiplying `count` by
-    ///   [`layout.size()`](Layout::size), rounded up to the nearest multiple of
-    ///   [`layout.align()`](Layout::align), would overflow.
+    ///   <code>layout.[size](Layout::size)()</code>, rounded up to the nearest multiple of
+    ///   <code>layout.[align](Layout::align)()</code>, would overflow.
     #[::rustversion::attr(since(1.47), const)]
     #[inline]
     pub fn repeat(&self, count: usize) -> Result<(Layout, usize), Error> {
@@ -390,8 +390,8 @@ impl Layout {
     ///
     /// # Errors
     ///
-    /// - <code>Err([Error::ArithmeticError])</code> if multiplying [`layout.size()`](Layout::size)
-    ///   by `count` would overflow.
+    /// - <code>Err([Error::ArithmeticError])</code> if multiplying
+    ///   <code>layout.[size](Layout::size)()</code> by `count` would overflow.
     /// - <code>Err([Error::InvalidLayout]\([self.size()](Layout::size) * count,
     ///   [self.align()](Layout::align), [LayoutErr::ExceedsMax]\))</code> if
     ///   <code>[self.size()](Layout::size) * count</code> rounded up to the nearest multiple of
@@ -499,9 +499,8 @@ impl Layout {
     /// ```
     #[inline]
     pub const fn to_posix_memalign_compatible(&self) -> Result<Layout, Error> {
-        // first, make the alignment a multiple of `size_of::<*mut c_void>()`.
+        // make the alignment a multiple of `size_of::<*mut c_void>()`.
         match self.align_to_multiple_of(usize::SZ) {
-            // then pad the size up to a multiple of the new alignment
             Ok(l) => Ok(l),
             Err(_) => Err(Error::InvalidLayout(self.size(), self.align(), LayoutErr::CRoundUp))
         }
diff --git a/src/traits/alloc.rs b/src/traits/alloc.rs
index 5379104..b7b364c 100644
--- a/src/traits/alloc.rs
+++ b/src/traits/alloc.rs
@@ -5,13 +5,13 @@ use {
         traits::{
             AllocError,
             alloc_mut::{AllocMut, DeallocMut, GrowMut, ReallocMut, ShrinkMut},
-            helpers::{Bytes, default_dealloc_panic, grow, ralloc, shrink_unchecked}
+            helpers::{default_dealloc_panic, ralloc}
         }
     },
     ::core::{
-        cmp::{Ord, Ordering},
         convert::From,
         marker::Sized,
+        option::Option::{None, Some},
         ptr::{self, NonNull},
         result::Result::{self, Err}
     }
@@ -32,7 +32,7 @@ pub trait Alloc: AllocError + AllocMut {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -50,7 +50,7 @@ pub trait Alloc: AllocError + AllocMut {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -66,7 +66,7 @@ pub trait Alloc: AllocError + AllocMut {
 pub trait Dealloc: Alloc + DeallocMut {
     /// Deallocates a previously allocated block.
     ///
-    /// This is a noop if <code>[layout.size()](Layout::size) == 0</code> or `ptr` is
+    /// This is a noop if <code>layout.[size](Layout::size)() == 0</code> or `ptr` is
     /// [`dangling`](ptr::dangling).
     ///
     /// The default implementation simply calls [`try_dealloc`](Dealloc::try_dealloc) and panics if
@@ -82,7 +82,7 @@ pub trait Dealloc: Alloc + DeallocMut {
     ///
     /// This function may panic if the [`try_dealloc`](Dealloc::try_dealloc) implementation returns
     /// an error, or the implementation chooses to panic for any other reason. It will not panic if
-    /// `ptr` is [`dangling`](ptr::dangling) or <code>[layout.size()](Layout::size) == 0</code>.
+    /// `ptr` is [`dangling`](ptr::dangling) or <code>layout.[size](Layout::size)() == 0</code>.
     #[track_caller]
     #[inline]
     unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {
@@ -104,7 +104,7 @@ pub trait Dealloc: Alloc + DeallocMut {
     /// Errors are implementation-defined, refer to [`AllocError::Error`] and [`Error`].
     ///
     /// The standard implementations may return:
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     /// - <code>Err([Error::DanglingDeallocation])</code> if <code>ptr ==
     ///   [layout.dangling](Layout::dangling)</code>.
@@ -151,14 +151,6 @@ pub trait Grow: Alloc + Dealloc + GrowMut {
     ///
     /// On failure, the original memory will not be deallocated.
     ///
-    /// Note that the default implementation simply:
-    /// 1. Checks that the new layout is larger or the same size. If both layouts are the same,
-    ///    `ptr` is returned and no operation is performed.
-    /// 2. Allocates a new block of memory via [`Alloc::alloc`].
-    /// 3. Copies [`old_layout.size()`](Layout::size) bytes from the old block to the new block.
-    /// 4. Deallocates the old block.
-    /// 5. Returns a pointer to the new block.
-    ///
     /// # Safety
     ///
     /// The caller must ensure:
@@ -174,10 +166,12 @@ pub trait Grow: Alloc + Dealloc + GrowMut {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::GrowSmallerNewLayout]\([old_layout.size()](Layout::size),
-    ///   [new_layout.size()](Layout::size))\)</code> if <code>[old_layout.size()](Layout::size) >
-    ///   [new_layout.size()](Layout::size)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::GrowSmallerNewLayout]\(old_layout.[size](Layout::size)(),
+    ///   new_layout.[size](Layout::size)())\)</code> if <code>old_layout.[size](Layout::size)() >
+    ///   new_layout.[size](Layout::size)()</code>.
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -190,21 +184,24 @@ pub trait Grow: Alloc + Dealloc + GrowMut {
         old_layout: Layout,
         new_layout: Layout
     ) -> Result<NonNull<u8>, <Self as AllocError>::Error> {
-        grow(self, ptr, old_layout, new_layout, Bytes::Uninitialized)
+        ralloc(
+            self,
+            ptr,
+            old_layout,
+            new_layout,
+            Alloc::alloc,
+            Some(<Self as AllocError>::Error::from(Error::GrowSmallerNewLayout(
+                old_layout.size(),
+                new_layout.size()
+            ))),
+            None
+        )
     }
 
     /// Grows the given block to a new, larger layout, with extra bytes being zeroed.
     ///
     /// On failure, the original memory will not be deallocated.
     ///
-    /// Note that the default implementation simply:
-    /// 1. Checks that the new layout is larger or the same size. If both layouts are the same,
-    ///    `ptr` is returned and no operation is performed.
-    /// 2. Allocates a new block of memory via [`Alloc::zalloc`].
-    /// 3. Copies [`old_layout.size()`](Layout::size) bytes from the old block to the new block.
-    /// 4. Deallocates the old block.
-    /// 5. Returns a pointer to the new block.
-    ///
     /// # Safety
     ///
     /// The caller must ensure:
@@ -220,10 +217,12 @@ pub trait Grow: Alloc + Dealloc + GrowMut {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::GrowSmallerNewLayout]\([old_layout.size()](Layout::size),
-    ///   [new_layout.size()](Layout::size))\)</code> if <code>[old_layout.size()](Layout::size) >
-    ///   [new_layout.size()](Layout::size)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::GrowSmallerNewLayout]\(old_layout.[size](Layout::size)(),
+    ///   new_layout.[size](Layout::size)())\)</code> if <code>old_layout.[size](Layout::size)() >
+    ///   new_layout.[size](Layout::size)()</code>.
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -236,7 +235,18 @@ pub trait Grow: Alloc + Dealloc + GrowMut {
         old_layout: Layout,
         new_layout: Layout
     ) -> Result<NonNull<u8>, <Self as AllocError>::Error> {
-        grow(self, ptr, old_layout, new_layout, Bytes::Zeroed)
+        ralloc(
+            self,
+            ptr,
+            old_layout,
+            new_layout,
+            Alloc::zalloc,
+            Some(<Self as AllocError>::Error::from(Error::GrowSmallerNewLayout(
+                old_layout.size(),
+                new_layout.size()
+            ))),
+            None
+        )
     }
 }
 
@@ -246,15 +256,6 @@ pub trait Shrink: Alloc + Dealloc + ShrinkMut {
     ///
     /// On failure, the original memory will not be deallocated.
     ///
-    /// Note that the default implementation simply:
-    /// 1. Checks that the new layout is smaller or the same size. If both layouts are the same,
-    ///    `ptr` is returned and no operation is performed.
-    /// 2. Allocates a new block of memory via [`Alloc::alloc`].
-    /// 3. Copies [`new_layout.size()`](Layout::size) bytes from the old block to the new block.
-    ///    This will discard any extra bytes from the old block.
-    /// 4. Deallocates the old block.
-    /// 5. Returns a pointer to the new block.
-    ///
     /// # Safety
     ///
     /// The caller must ensure:
@@ -270,10 +271,12 @@ pub trait Shrink: Alloc + Dealloc + ShrinkMut {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ShrinkLargerNewLayout]\([old_layout.size()](Layout::size),
-    ///   [new_layout.size()](Layout::size))\)</code> if <code>[old_layout.size()](Layout::size) <
-    ///   [new_layout.size()](Layout::size)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ShrinkLargerNewLayout]\(old_layout.[size](Layout::size)(),
+    ///   new_layout.[size](Layout::size)())\)</code> if <code>old_layout.[size](Layout::size)() <
+    ///   new_layout.[size](Layout::size)()</code>.
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -285,7 +288,18 @@ pub trait Shrink: Alloc + Dealloc + ShrinkMut {
         old_layout: Layout,
         new_layout: Layout
     ) -> Result<NonNull<u8>, <Self as AllocError>::Error> {
-        default_shrink!(self::shrink_unchecked, ptr, old_layout, new_layout)
+        ralloc(
+            self,
+            ptr,
+            old_layout,
+            new_layout,
+            Alloc::alloc,
+            None,
+            Some(<Self as AllocError>::Error::from(Error::ShrinkLargerNewLayout(
+                old_layout.size(),
+                new_layout.size()
+            )))
+        )
     }
 }
 
@@ -293,8 +307,8 @@ pub trait Shrink: Alloc + Dealloc + ShrinkMut {
 pub trait Realloc: Grow + Shrink + ReallocMut {
     /// Reallocates a block, growing or shrinking as needed.
     ///
-    /// On grow, preserves existing contents up to [`old_layout.size()`](Layout::size), and on
-    /// shrink, truncates to [`new_layout.size()`](Layout::size).
+    /// On grow, preserves existing contents up to <code>old_layout.[size](Layout::size)()</code>,
+    /// and on shrink, truncates to <code>new_layout.[size](Layout::size)()</code>.
     ///
     /// On failure, the original memory will not be deallocated.
     ///
@@ -313,7 +327,9 @@ pub trait Realloc: Grow + Shrink + ReallocMut {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -326,13 +342,13 @@ pub trait Realloc: Grow + Shrink + ReallocMut {
         old_layout: Layout,
         new_layout: Layout
     ) -> Result<NonNull<u8>, <Self as AllocError>::Error> {
-        ralloc(self, ptr, old_layout, new_layout, Bytes::Uninitialized)
+        ralloc(self, ptr, old_layout, new_layout, Alloc::alloc, None, None)
     }
 
     /// Reallocates a block, growing or shrinking as needed, with extra bytes being zeroed.
     ///
-    /// On grow, preserves existing contents up to [`old_layout.size()`](Layout::size), and on
-    /// shrink, truncates to [`new_layout.size()`](Layout::size).
+    /// On grow, preserves existing contents up to <code>old_layout.[size](Layout::size)()</code>,
+    /// and on shrink, truncates to <code>new_layout.[size](Layout::size)()</code>.
     ///
     /// On failure, the original memory will not be deallocated.
     ///
@@ -351,7 +367,9 @@ pub trait Realloc: Grow + Shrink + ReallocMut {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -364,7 +382,7 @@ pub trait Realloc: Grow + Shrink + ReallocMut {
         old_layout: Layout,
         new_layout: Layout
     ) -> Result<NonNull<u8>, <Self as AllocError>::Error> {
-        ralloc(self, ptr, old_layout, new_layout, Bytes::Zeroed)
+        ralloc(self, ptr, old_layout, new_layout, Alloc::zalloc, None, None)
     }
 }
 
diff --git a/src/traits/alloc_mut.rs b/src/traits/alloc_mut.rs
index ee8f93f..37e514a 100644
--- a/src/traits/alloc_mut.rs
+++ b/src/traits/alloc_mut.rs
@@ -37,7 +37,7 @@ pub trait AllocMut: AllocError {
     ///   feature is enabled, it will be
     ///   <code>[Cause::OSErr](crate::error::Cause::OSErr)(oserr)</code>. In this case, `oserr` will
     ///   be the error from <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -56,7 +56,7 @@ pub trait AllocMut: AllocError {
     ///   feature is enabled, it will be
     ///   <code>[Cause::OSErr](crate::error::Cause::OSErr)(oserr)</code>. In this case, `oserr` will
     ///   be the error from <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -76,7 +76,7 @@ pub trait AllocMut: AllocError {
 pub trait DeallocMut: AllocMut {
     /// Deallocates a previously allocated block.
     ///
-    /// This is a noop if <code>[layout.size()](Layout::size) == 0</code> or `ptr` is
+    /// This is a noop if <code>layout.[size](Layout::size)() == 0</code> or `ptr` is
     /// [`dangling`](ptr::dangling).
     ///
     /// The default implementation simply calls [`try_dealloc_mut`](DeallocMut::try_dealloc_mut) and
@@ -93,7 +93,7 @@ pub trait DeallocMut: AllocMut {
     /// This function may panic if the [`try_dealloc_mut`](DeallocMut::try_dealloc_mut)
     /// implementation returns an error, or the implementation chooses to panic for any other
     /// reason. It will not panic if `ptr` is [`dangling`](ptr::dangling) or
-    /// <code>[layout.size()](Layout::size) == 0</code>.
+    /// <code>layout.[size](Layout::size)() == 0</code>.
     #[track_caller]
     #[inline]
     unsafe fn dealloc_mut(&mut self, ptr: NonNull<u8>, layout: Layout) {
@@ -115,7 +115,7 @@ pub trait DeallocMut: AllocMut {
     /// Errors are implementation-defined, refer to [`AllocError::Error`] and [`Error`].
     ///
     /// The standard implementations may return:
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     /// - <code>Err([Error::DanglingDeallocation])</code> if <code>ptr ==
     ///   [layout.dangling](Layout::dangling)</code>.
@@ -157,14 +157,6 @@ pub trait GrowMut: AllocMut + DeallocMut {
     ///
     /// On failure, the original memory will not be deallocated.
     ///
-    /// Note that the default implementation simply:
-    /// 1. Checks that the new layout is larger or the same size. If both layouts are the same,
-    ///    `ptr` is returned and no operation is performed.
-    /// 2. Allocates a new block of memory via [`AllocMut::alloc_mut`].
-    /// 3. Copies [`old_layout.size()`](Layout::size) bytes from the old block to the new block.
-    /// 4. Deallocates the old block.
-    /// 5. Returns a pointer to the new block.
-    ///
     /// # Safety
     ///
     /// The caller must ensure:
@@ -181,10 +173,12 @@ pub trait GrowMut: AllocMut + DeallocMut {
     ///   feature is enabled, it will be
     ///   <code>[Cause::OSErr](crate::error::Cause::OSErr)(oserr)</code>. In this case, `oserr` will
     ///   be the error from <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::GrowSmallerNewLayout]\([old_layout.size()](Layout::size),
-    ///   [new_layout.size()](Layout::size))\)</code> if <code>[old_layout.size()](Layout::size) >
-    ///   [new_layout.size()](Layout::size)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[new_layout.size()](Layout::size) ==
+    /// - <code>Err([Error::GrowSmallerNewLayout]\(old_layout.[size](Layout::size)(),
+    ///   new_layout.[size](Layout::size)())\)</code> if <code>old_layout.[size](Layout::size)() >
+    ///   new_layout.[size](Layout::size)()</code>.
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>new_layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -204,14 +198,6 @@ pub trait GrowMut: AllocMut + DeallocMut {
     ///
     /// On failure, the original memory will not be deallocated.
     ///
-    /// Note that the default implementation simply:
-    /// 1. Checks that the new layout is larger or the same size. If both layouts are the same,
-    ///    `ptr` is returned and no operation is performed.
-    /// 2. Allocates a new block of memory via [`AllocMut::zalloc_mut`].
-    /// 3. Copies [`old_layout.size()`](Layout::size) bytes from the old block to the new block.
-    /// 4. Deallocates the old block.
-    /// 5. Returns a pointer to the new block.
-    ///
     /// # Safety
     ///
     /// The caller must ensure:
@@ -228,10 +214,12 @@ pub trait GrowMut: AllocMut + DeallocMut {
     ///   feature is enabled, it will be
     ///   <code>[Cause::OSErr](crate::error::Cause::OSErr)(oserr)</code>. In this case, `oserr` will
     ///   be the error from <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::GrowSmallerNewLayout]\([old_layout.size()](Layout::size),
-    ///   [new_layout.size()](Layout::size))\)</code> if <code>[old_layout.size()](Layout::size) >
-    ///   [new_layout.size()](Layout::size)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[new_layout.size()](Layout::size) ==
+    /// - <code>Err([Error::GrowSmallerNewLayout]\(old_layout.[size](Layout::size)(),
+    ///   new_layout.[size](Layout::size)())\)</code> if <code>old_layout.[size](Layout::size)() >
+    ///   new_layout.[size](Layout::size)()</code>.
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>new_layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -257,15 +245,6 @@ pub trait ShrinkMut: AllocMut + DeallocMut {
     ///
     /// On failure, the original memory will not be deallocated.
     ///
-    /// Note that the default implementation simply:
-    /// 1. Checks that the new layout is smaller or the same size. If both layouts are the same,
-    ///    `ptr` is returned and no operation is performed.
-    /// 2. Allocates a new block of memory via [`AllocMut::alloc_mut`].
-    /// 3. Copies [`new_layout.size()`](Layout::size) bytes from the old block to the new block.
-    ///    This will discard any extra bytes from the old block.
-    /// 4. Deallocates the old block.
-    /// 5. Returns a pointer to the new block.
-    ///
     /// # Safety
     ///
     /// The caller must ensure:
@@ -282,10 +261,12 @@ pub trait ShrinkMut: AllocMut + DeallocMut {
     ///   feature is enabled, it will be
     ///   <code>[Cause::OSErr](crate::error::Cause::OSErr)(oserr)</code>. In this case, `oserr` will
     ///   be the error from <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ShrinkLargerNewLayout]\([old_layout.size()](Layout::size),
-    ///   [new_layout.size()](Layout::size))\)</code> if <code>[old_layout.size()](Layout::size) <
-    ///   [new_layout.size()](Layout::size)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[new_layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ShrinkLargerNewLayout]\(old_layout.[size](Layout::size)(),
+    ///   new_layout.[size](Layout::size)())\)</code> if <code>old_layout.[size](Layout::size)() <
+    ///   new_layout.[size](Layout::size)()</code>.
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>new_layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -309,8 +290,8 @@ pub trait ShrinkMut: AllocMut + DeallocMut {
 pub trait ReallocMut: GrowMut + ShrinkMut {
     /// Reallocates a block, growing or shrinking as needed.
     ///
-    /// On grow, preserves existing contents up to [`old_layout.size()`](Layout::size), and on
-    /// shrink, truncates to [`new_layout.size()`](Layout::size).
+    /// On grow, preserves existing contents up to <code>old_layout.[size](Layout::size)()</code>,
+    /// and on shrink, truncates to <code>new_layout.[size](Layout::size)()</code>.
     ///
     /// On failure, the original memory will not be deallocated.
     ///
@@ -330,7 +311,9 @@ pub trait ReallocMut: GrowMut + ShrinkMut {
     ///   feature is enabled, it will be
     ///   <code>[Cause::OSErr](crate::error::Cause::OSErr)(oserr)</code>. In this case, `oserr` will
     ///   be the error from <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[new_layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>new_layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
@@ -348,8 +331,8 @@ pub trait ReallocMut: GrowMut + ShrinkMut {
 
     /// Reallocates a block, growing or shrinking as needed, with extra bytes being zeroed.
     ///
-    /// On grow, preserves existing contents up to [`old_layout.size()`](Layout::size), and on
-    /// shrink, truncates to [`new_layout.size()`](Layout::size).
+    /// On grow, preserves existing contents up to <code>old_layout.[size](Layout::size)()</code>,
+    /// and on shrink, truncates to <code>new_layout.[size](Layout::size)()</code>.
     ///
     /// On failure, the original memory will not be deallocated.
     ///
@@ -369,7 +352,9 @@ pub trait ReallocMut: GrowMut + ShrinkMut {
     ///   feature is enabled, it will be
     ///   <code>[Cause::OSErr](crate::error::Cause::OSErr)(oserr)</code>. In this case, `oserr` will
     ///   be the error from <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[new_layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ReallocSmallerAlign]\(old, new\))</code> if
+    ///   <code>old_layout.[align](Layout::align)() > new_layout.[align](Layout::align)()</code>.
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>new_layout.[size](Layout::size)() ==
     ///   0</code>.
     ///
     /// [last_os_error]: ::std::io::Error::last_os_error
diff --git a/src/traits/alloc_temp.rs b/src/traits/alloc_temp.rs
index ee0c4a1..75b0741 100644
--- a/src/traits/alloc_temp.rs
+++ b/src/traits/alloc_temp.rs
@@ -28,7 +28,7 @@ pub trait AllocTemp {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     /// - <code>Err([Error::CaughtUnwind])</code> if the `catch_unwind` feature is enabled and an
     ///   unwind occurs in a function which is not allowed to unwind.
@@ -57,7 +57,7 @@ pub trait AllocTemp {
     ///   typically [`Cause::Unknown`]. If the `os_err_reporting` feature is enabled, it will be
     ///   <code>[Cause::OSErr]\(oserr\)</code>. In this case, `oserr` will be the error from
     ///   <code>[last_os_error]\(\).[raw_os_error]\(\)</code>.
-    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>[layout.size()](Layout::size) ==
+    /// - <code>Err([Error::ZeroSizedLayout])</code> if <code>layout.[size](Layout::size)() ==
     ///   0</code>.
     /// - <code>Err([Error::CaughtUnwind])</code> if the `catch_unwind` feature is enabled and an
     ///   unwind occurs in a function which is not allowed to unwind.
diff --git a/src/traits/helpers.rs b/src/traits/helpers.rs
index d089e98..d40b3ad 100644
--- a/src/traits/helpers.rs
+++ b/src/traits/helpers.rs
@@ -1,14 +1,12 @@
 use {
-    crate::{
-        error::Error,
-        layout::Layout,
-        traits::alloc::{Grow, Realloc, Shrink}
-    },
+    crate::{error::Error, layout::Layout, traits::alloc::Dealloc},
     ::core::{
-        cmp::{Ord, Ordering},
+        cmp::{Ord, Ordering, min},
         convert::From,
         fmt::{Debug, Display},
+        hint::unreachable_unchecked,
         marker::Sized,
+        option::Option::{self},
         panic,
         ptr::{self, NonNull},
         result::Result::{self, Err, Ok}
@@ -21,88 +19,44 @@ pub fn default_dealloc_panic<E: Display>(ptr: NonNull<u8>, layout: Layout, e: E)
 
 //noinspection DuplicatedCode
 #[cfg_attr(miri, track_caller)]
-pub unsafe fn grow<A: Grow<Error = E> + ?Sized, E: From<Error> + Debug + Display>(
+pub unsafe fn ralloc<A: Dealloc<Error = E> + ?Sized, E: From<Error> + Debug + Display>(
     a: &A,
     ptr: NonNull<u8>,
-    old_layout: Layout,
-    new_layout: Layout,
-    b: Bytes
+    old: Layout,
+    new: Layout,
+    alloc: fn(&A, Layout) -> Result<NonNull<u8>, E>,
+    less: Option<E>,
+    greater: Option<E>
 ) -> Result<NonNull<u8>, E> {
-    match new_layout.size().cmp(&old_layout.size()) {
-        Ordering::Greater => grow_unchecked(a, ptr, old_layout, new_layout, b),
-        Ordering::Equal => {
-            // TODO: maybe smaller align should be an error? in most cases that's ub
-            if new_layout.align() > old_layout.align() {
-                grow_unchecked(a, ptr, old_layout, new_layout, b)
-            } else {
-                Ok(ptr)
-            }
-        }
-        Ordering::Less => {
-            Err(E::from(Error::GrowSmallerNewLayout(old_layout.size(), new_layout.size())))
-        }
-    }
-}
-
-#[cfg_attr(miri, track_caller)]
-pub unsafe fn grow_unchecked<A: Grow<Error = E> + ?Sized, E: From<Error> + Debug + Display>(
-    a: &A,
-    ptr: NonNull<u8>,
-    old_layout: Layout,
-    new_layout: Layout,
-    b: Bytes
-) -> Result<NonNull<u8>, E> {
-    let old_size = old_layout.size();
-    let new_ptr = match b {
-        Bytes::Uninitialized => tri!(do a.alloc(new_layout)),
-        Bytes::Zeroed => tri!(do a.zalloc(new_layout))
-    };
+    let old_align = old.align();
+    let new_align = new.align();
 
-    if old_size != 0 {
-        ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), old_size);
-        tri!(do a.try_dealloc(ptr, old_layout));
+    if new_align < old_align {
+        return Err(E::from(Error::ReallocSmallerAlign(old_align, new_align)));
     }
 
-    Ok(new_ptr)
-}
+    let old_size = old.size();
+    let new_size = new.size();
 
-#[cfg_attr(miri, track_caller)]
-pub unsafe fn shrink_unchecked<A: Shrink<Error = E> + ?Sized, E: From<Error> + Debug + Display>(
-    a: &A,
-    ptr: NonNull<u8>,
-    old_layout: Layout,
-    new_layout: Layout
-) -> Result<NonNull<u8>, E> {
-    let new_ptr = tri!(do a.alloc(new_layout));
-
-    if old_layout.is_nonzero_sized() {
-        ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), new_layout.size());
-        tri!(do a.try_dealloc(ptr, old_layout));
-    }
-
-    Ok(new_ptr)
-}
-
-//noinspection DuplicatedCode
-#[cfg_attr(miri, track_caller)]
-pub unsafe fn ralloc<A: Realloc<Error = E> + ?Sized, E: From<Error> + Debug + Display>(
-    a: &A,
-    ptr: NonNull<u8>,
-    old_layout: Layout,
-    new_layout: Layout,
-    b: Bytes
-) -> Result<NonNull<u8>, E> {
-    match new_layout.size().cmp(&old_layout.size()) {
-        Ordering::Greater => grow_unchecked(&a, ptr, old_layout, new_layout, b),
+    let new_ptr = match new_size.cmp(&old_size) {
+        Ordering::Greater => greater.map_or_else(|| alloc(a, new), |greater| Err(greater)),
         Ordering::Equal => {
-            if new_layout.align() > old_layout.align() {
-                shrink_unchecked(&a, ptr, old_layout, new_layout)
-            } else {
-                Ok(ptr)
+            match new_align.cmp(&old_align) {
+                Ordering::Greater => alloc(a, new),
+                Ordering::Equal => Ok(ptr),
+                // SAFETY: we check above that new_align >= old_align
+                Ordering::Less => unsafe { unreachable_unchecked() }
             }
         }
-        Ordering::Less => shrink_unchecked(&a, ptr, old_layout, new_layout)
+        Ordering::Less => less.map_or_else(|| alloc(a, new), |less| Err(less))
+    };
+    if let Ok(new_ptr) = new_ptr {
+        if old_size > 0 {
+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), min(old_size, new_size));
+            tri!(do a.try_dealloc(ptr, old));
+        }
     }
+    new_ptr
 }
 
 #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
@@ -143,10 +97,12 @@ pub mod alloc_mut {
         match old_layout.size().cmp(&new_layout.size()) {
             Ordering::Less => grow_unchecked_mut(a, ptr, old_layout, new_layout, b),
             Ordering::Equal => {
-                if new_layout.align() > old_layout.align() {
-                    grow_unchecked_mut(a, ptr, old_layout, new_layout, b)
-                } else {
-                    Ok(ptr)
+                let old_align = old_layout.align();
+                let new_align = new_layout.align();
+                match new_align.cmp(&old_align) {
+                    Ordering::Greater => grow_unchecked_mut(a, ptr, old_layout, new_layout, b),
+                    Ordering::Equal => Ok(ptr),
+                    Ordering::Less => Err(E::from(Error::ReallocSmallerAlign(old_align, new_align)))
                 }
             }
             Ordering::Greater => {
@@ -214,10 +170,12 @@ pub mod alloc_mut {
         match old_layout.size().cmp(&new_layout.size()) {
             Ordering::Less => grow_unchecked_mut(a, ptr, old_layout, new_layout, b),
             Ordering::Equal => {
-                if new_layout.align() > old_layout.align() {
-                    grow_unchecked_mut(a, ptr, old_layout, new_layout, b)
-                } else {
-                    Ok(ptr)
+                let old_align = old_layout.align();
+                let new_align = new_layout.align();
+                match new_align.cmp(&old_align) {
+                    Ordering::Greater => shrink_unchecked_mut(a, ptr, old_layout, new_layout),
+                    Ordering::Equal => Ok(ptr),
+                    Ordering::Less => Err(E::from(Error::ReallocSmallerAlign(old_align, new_align)))
                 }
             }
             Ordering::Greater => shrink_unchecked_mut(a, ptr, old_layout, new_layout)
diff --git a/test.sh b/test.sh
index bda964a..423df2b 100755
--- a/test.sh
+++ b/test.sh
@@ -5,26 +5,26 @@ export MIRIFLAGS=-Zmiri-permissive-provenance
 export RUSTDOCFLAGS="-D warnings"
 
 echo "clippy: stable"
-cargo +stable clippy -- -D unused_unsafe -D warnings  > /dev/null
+cargo +stable clippy --features "full" -- -D unused_unsafe -D warnings  > /dev/null
 echo "clippy: nightly"
-cargo +nightly clippy -- -D unused_unsafe -D warnings > /dev/null
+cargo +nightly clippy --features "full_nightly" -- -D unused_unsafe -D warnings > /dev/null
 
 # msrv
 echo "test: 1.46"
-cargo +1.46.0 test --features full_msrv > /dev/null
+cargo +1.46.0 test --features "full_msrv" > /dev/null
 # random versions ive noticed problems with
 echo "test: 1.56"
-cargo +1.56.0 test --features full_msrv > /dev/null
+cargo +1.56.0 test --features "full_msrv,dev" > /dev/null
 echo "test: 1.64"
-cargo +1.64.0 test --features full > /dev/null
+cargo +1.64.0 test --features "full,dev" > /dev/null
 echo "test: 1.81"
-cargo +1.81.0 test --features full_msrv > /dev/null
+cargo +1.81.0 test --features "full,dev" > /dev/null
 echo "test: 1.89"
-cargo +1.89.0 test --features full_msrv > /dev/null
+cargo +1.89.0 test --features "full,dev" > /dev/null
 # main versions
 echo "test: stable"
-cargo +stable test --features full > /dev/null
+cargo +stable test --features "full,dev" > /dev/null
 echo "test: nightly (miri)"
-cargo +nightly miri test --features full_nightly > /dev/null
+cargo +nightly miri test --features "full_nightly,dev" > /dev/null
 
-cargo +nightly doc --features "full_nightly" > /dev/null
+cargo +nightly doc --features "full_nightly,dev" > /dev/null
